<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>gantt</title>
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/zrender/5.4.4/zrender.min.js"></script> -->
  <script src="./zrender.min.js"></script>
  <style>
    #zrender-container,
    #off-screen {
      outline: 1px solid red;
      /* margin: 20px 0 0 150px; */
    }

    .popup-wrapper {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background-color: rgba(255, 0, 0, 0.3);
      /* display: flex; */
      align-items: center;
      justify-content: center;
      flex-direction: column;
      display: none;
    }

    .popup-wrapper .popup-wrapper__body {
      width: 337px;
    }
    .popup-wrapper .popup-wrapper__body .button-wrapper button {
      display: block;
    }

    .popup-wrapper .popup-wrapper__body textarea {
      display: block;
      width: 100%;
    }

    .popup-wrapper .popup-wrapper__body .button-wrapper {
      display: flex;
      justify-content: space-between;
    }

    .popup-wrapper .popup-wrapper__body .button-wrapper button {
      width: 100px;
      height: 32px;
      cursor: pointer;
    }
    .popup-wrapper .popup-wrapper__body .button-wrapper button.delete:hover {
      background-color: #f00;
      outline: none;
      border-color: #f00;
      color: #fff;
    }
    .popup-wrapper .popup-wrapper__body .button-wrapper button.copy:hover {
      background-color: #86a5e5;
      outline: none;
      border-color: #86a5e5;
      color: #fff;
    }
    .popup-wrapper .popup-wrapper__body .button-wrapper button.modify:hover {
      background-color: #1f8a6f;
      outline: none;
      border-color: #1f8a6f;
      color: #fff;
    }
  </style>
</head>

<body>
  <div class="control-item">
    <!-- Reset the scroll button -->
    <button id="back-to-origin-button">重置滚动</button>
    <span id="last-scroll-x">0</span>
  </div>
  <div class="control-item" style="display: none;">
    <!-- clear all tasks -->
    <button id="clear-button">清空任务</button>
    <button id="clear-milestone-button">清空里程</button>
  </div>
  <!-- Create a container for the ZRender instance -->
  <div id="zrender-container" style="height: 700px;"></div>
  <!-- popup 提示框 -->
  <div class="popup-wrapper">
    <div class="popup-wrapper__body">
      <form>
        <textarea name="taskvalue" cols="30" rows="10" id="current-task" data-index="0"></textarea>
        <div class="button-wrapper">
          <button class="modify">修改</button>
          <button class="delete">删除</button>
          <button class="copy">复制</button>
        </div>
      </form>
    </div>
  </div>
  <script src="./popup.js"></script>
  <script src="./hachure.js"></script>
  <script src="./holidays.js"></script>
  <script src="./controls.js"></script>
  <script src="./utils.js"></script>
  <script src="./flag.js"></script>
  <script src="./task.js"></script>
  <script src="./today.js"></script>
  <script>
    let currentGroup = null;
    let lastHandleMove = null;
    const debug = getParamsFromSearch('debug') ?? false;

    const defaultTaskOwner = 'alexq';
    // Initialize ZRender
    const zr = zrender.init(document.getElementById("zrender-container"), {
      renderer: 'canvas'
    });
    // unit width of the column
    let unitWidth = getParamsFromSearch() ?? 160;
    // half unit width
    let halfUnitWidth = unitWidth / 2;
    // taskName paddingLeft
    let taskNamePaddingLeft = getParamsFromSearch('taskNamePaddingLeft') ?? 15;
    const initChartStartX = 1, initChartStartY = 50;
    // time scale height
    const timeScaleHeight = getParamsFromSearch('timeScaleHeight') ?? 20;
    // milestone top height
    const milestoneTopHeight = getParamsFromSearch('milestoneTopHeight') ?? 20;
    // taskBar height
    const barHeight = getParamsFromSearch('barHeight') ?? 30;
    // taskBar margin bottom
    const barMargin = debug ? 10 : (getParamsFromSearch('barMargin') ?? 1);
    // scroll speed [1, 100]
    const scrollSpeed = getParamsFromSearch('scrollSpeed') ?? 35;
    // includeHoliday hell no!!!
    const includeHoliday = getParamsFromSearch('includeHoliday') ?? false;
    // if use local data
    const useLocal = getParamsFromSearch('useLocal');
    // if use remote data
    const useRemote = getParamsFromSearch('useRemote');
    // query view
    const view = getParamsFromSearch('view', false) ?? ''
    if (useRemote) {
      document.title += ' (Remote)'
      initData()
    }
    // mockTaskSize for test only enabled when useLocal is false
    const mockTaskSize = !useRemote && !useLocal && getParamsFromSearch('mockTaskSize') ? Number(getParamsFromSearch('mockTaskSize')) : 5;
    // Define tasks for the Gantt chart
    const tasks = useLocal ? getLocal() : [
      { name: "Task 1", start: 0, duration: 3, resource: "John", fillColor: getRandomColor() },
      { name: "Task 2", start: 2, duration: 4, resource: "Jane", fillColor: getRandomColor() },
      { name: "Task 3 long long long", start: 7, duration: 1, resource: "Bob", fillColor: getRandomColor() },
      { name: "Task 4", start: 8, duration: 2, resource: "Bose", fillColor: getRandomColor() },
      { name: "Task 5", start: 10, duration: 8, resource: "Uno", fillColor: getRandomColor() },
      {}
      // Add more tasks as needed
    ];
    while(tasks.length < mockTaskSize) {
      const lastTask = tasks.pop();
      tasks.push(...[...tasks, lastTask]);
    }
    window.tasks = tasks;

    // Define the milestones
    const mileStones = useLocal ? getLocal('mileStones') : [
      { start: 10, name: '提测' }
    ];
    window.mileStones = mileStones;
    const todayOffset = Math.floor((+new Date() - +new Date('2024-01-01')) / (60 * 60 * 24 * 1000))

    // scroll horizontally
    // 默认设置到今天左边一格
    let lastScrollX = 0 + (todayOffset - 1) * unitWidth, lastScrollY = 0;
    // 显示scrollX的值
    const $lastScrollXSpan = document.querySelector('#last-scroll-x');
    zr.on('mousewheel', function (e) {
      e.event.preventDefault();
      // console.log(e.event, e.event.wheelDeltaX);
      // set speed for the scroll
      lastScrollX -= Math.floor(e.event.wheelDeltaX * 0.01 * scrollSpeed);
      redrawChart(true, lastScrollX, 0);
      $lastScrollXSpan.innerText = lastScrollX;
    })
    // redraw when browser window size change
    window.addEventListener('resize', function() {
      zr.resize();
      redrawChart(true);
    });

    function redrawChart(clear, scrollX = lastScrollX, scrollY = 0) {
      // margin left to the container
      const chartStartX = initChartStartX - scrollX;
      // margin top to the container
      const chartStartY = Math.max(initChartStartY, timeScaleHeight + milestoneTopHeight) - scrollY;
      // clear the painter
      clear && zr.clear();
      const canvasWidth = zr.getWidth();
      const canvasHeight = zr.getHeight();

      const boundingLeft = Math.floor(lastScrollX / unitWidth);
      const boundingRight = Math.floor((lastScrollX + canvasWidth) / unitWidth);
      // hover day grid to add task
      let lastPos
      let lastDayRect
      function handleMove(e) {
        if (currentGroup?.resizing || currentGroup?.dragging) {
          return
        }
        const x = e.event.zrX - chartStartX
        const y = e.event.zrY - chartStartY
        const posX = Math.floor(x / unitWidth)
        const posY = Math.floor(y / (barHeight + barMargin))
        if (lastPos !== [posX, posY].join()) {
          lastPos = [posX, posY].join()
          // if (true || (posX >= 0 && posX < timeScaleWidth && posY >= 0 && posY < tasks.length)) {
          if (posY >= 0 && posY < tasks.length) {
            // console.log('zr', 'clicked', posX, posY)
            const hasTask = posX >= tasks[posY].start && posX < tasks[posY].start + tasks[posY].duration
            if (hasTask) {
              lastDayRect && zr.remove(lastDayRect)
              return
            }
            const dayHoverGroup = new zrender.Group()
            dayHoverGroup.on('click', function () {
              console.log('dayHoverGroup clicked pos: ', [posX, posY])
              // alert([posX, posY])
              const taskName = prompt('task name?');
              if (!taskName) return
              const resourceName = prompt('assign to who?') || defaultTaskOwner;
              tasks.splice(posY, 0, { name: taskName, start: posX, duration: 1, resource: resourceName, fillColor: getRandomColor() });
              syncLocal();
              redrawChart(true)
            })
            // draw the hover rect on the day grid
            const dayRect = new zrender.Rect({
              shape: {
                x: chartStartX + unitWidth * posX + 5,
                y: chartStartY + (barHeight + barMargin) * posY,
                width: unitWidth - 10,
                height: barHeight + barMargin,
              },
              style: {
                fill: 'transparent',
                stroke: 'gray',
                lineDash: [5, 7]
              },
              z: 100
            })
            const rowHoverRect = new zrender.Rect({
              shape: {
                x: chartStartX + lastScrollX,
                y: chartStartY + (barHeight + barMargin) * posY,
                width: unitWidth * timeScaleWidth,
                height: barHeight + barMargin,
              },
              style: {
                fill: 'rgba(221, 221, 221, 0.3)',
              },
              z: 1
            })
            const lineH = new zrender.Line({
              shape: {
                x1: chartStartX + unitWidth * posX + unitWidth / 2 - 5,
                y1: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2,
                x2: chartStartX + unitWidth * posX + unitWidth / 2 + 5,
                y2: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2
              },
              style: {
                stroke: 'gray'
              },
              z: 100
            })
            const lineV = new zrender.Line({
              shape: {
                x1: chartStartX + unitWidth * posX + unitWidth / 2,
                y1: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2 - 5,
                x2: chartStartX + unitWidth * posX + unitWidth / 2,
                y2: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2 + 5
              },
              style: {
                stroke: 'gray'
              },
              z: 100
            })
            dayHoverGroup.add(dayRect)
            dayHoverGroup.add(lineH)
            dayHoverGroup.add(lineV)
            dayHoverGroup.add(rowHoverRect)
            lastDayRect && zr.remove(lastDayRect)
            lastDayRect = dayHoverGroup
            zr.add(dayHoverGroup)
          } else {
            lastDayRect && zr.remove(lastDayRect)
            // console.log('invalid pos')
          }
        } else {
          // lastDayRect && zr.remove(lastDayRect)
          // console.log('same as the last pos')
        }
      }
      lastHandleMove && zr.off('mousemove', lastHandleMove)
      lastHandleMove = handleMove
      zr.on('mousemove', handleMove);

      const timeScaleWidth = Math.ceil((canvasWidth) / unitWidth);
      // Draw time scale
      // MARK: 日期时间轴
      const timeScale = new zrender.Rect({
        shape: {
          x: chartStartX + lastScrollX,
          y: chartStartY - timeScaleHeight,
          width: timeScaleWidth * unitWidth,
          height: timeScaleHeight
        },
        style: {
          // fill: "lightgray"
          fill: "rgba(255, 0,0, .2)"
        }
      });
      zr.add(timeScale);

      // Draw vertical grid lines
      // MARK: grid 竖线
      const gridStartX = chartStartX;
      const gridEndX = timeScaleWidth * unitWidth;
      const gridLineCount = timeScaleWidth + 1;
      const deltaScrollX = Math.floor(lastScrollX / unitWidth);
      for (let i = 0 + deltaScrollX, count = 0; count < gridLineCount; i++,count++) {
        // perf: 
        const viewPortTaskLength = Math.min(tasks.length, (canvasHeight - chartStartY) / (barHeight + barMargin))
        const gridX = gridStartX + i * unitWidth;
        const gridLine = new zrender.Line({
          shape: {
            x1: gridX,
            y1: chartStartY - timeScaleHeight,
            x2: gridX,
            y2: chartStartY + (barHeight + barMargin) * viewPortTaskLength
          },
          style: {
            stroke: "lightgray"
          }
        });

        // Draw the date
        if (count < gridLineCount - 1) {
          // MARK: 同一个遍历画「休息日斜线」
          const now = +new Date('2024-01-01');
          const currentDate = now + i * 60 * 1000 * 60 * 24
          const dateInfo = isHoliday(currentDate)
          // Draw the hachure fill 画斜线
          if (dateInfo.isHoliday) {
            // if (i % 7 == 0 || i % 7 === 1) {
            try {
              const lines = hachureLines([
                [chartStartX + i * unitWidth, chartStartY],
                [chartStartX + i * unitWidth + unitWidth, chartStartY],
                [chartStartX + i * unitWidth + unitWidth, chartStartY + (barHeight + barMargin) * viewPortTaskLength],
                [chartStartX + i * unitWidth, chartStartY + (barHeight + barMargin) * viewPortTaskLength]
              ], 10, 45);
              // console.log(lines)
              lines.forEach(line => {
                const [x1, y1] = line[0]
                const [x2, y2] = line[1]
                const l = new zrender.Line({
                  shape: {
                    x1, y1, x2, y2
                  },
                  style: {
                    stroke: 'rgba(221, 221, 221, 0.7)'
                  }
                })
                zr.add(l)
              })
            } catch (error) {
              console.log(error)
            }
          }
          // MARK: 画日期文字
          const dateText = new zrender.Text({
            style: {
              // text: i,
              text: dateInfo.dateString,
              x: gridX,
              y: chartStartY - timeScaleHeight,
            },
            z: 1
          });
          const [flagGroup, {
            flag
          }] = createFlagGroup(gridX, halfUnitWidth, chartStartY, timeScaleHeight)
          dateText.on('click', function () {
            console.log('date text click', i);
            const index = mileStones.findIndex(item => item.start === i)
            if (index === -1) {
              if (confirm('Do you want to CREATE a milestone here?')) {
                const mileStoneName = prompt('mileStone name?');
                mileStones.push({
                  start: i,
                  name: mileStoneName
                });
                syncLocal();
              }
            } else {
              if (confirm('Do you want to DELETE the milestone here?')) {
                mileStones.splice(index, 1)
                syncLocal();
              }
            }
            redrawChart(true)
          })
          dateText.on('mouseover', function (e) {
            this.attr({
              style: {
                opacity: 0
              }
            });
            flagGroup.show()
          })
          dateText.on('mouseout', function (e) {
            this.attr({
              style: {
                opacity: 1
              }
            });
            flagGroup.hide()
          })

          const { width, height } = dateText.getBoundingRect()
          dateText.attr({
            style: {
              x: gridX - width / 2 + halfUnitWidth,
              y: chartStartY - timeScaleHeight - height / 2 + timeScaleHeight / 2,
            }
          })
          zr.add(dateText);
        }
        zr.add(gridLine);
      }

      // Draw horizontally grid lines
      // MARK: 画grid横线
      const gridLineCountY = tasks.length + 1;

      for (let j = 0; j < 1; j++) {
        const gridY = chartStartY + j * (barHeight + barMargin);
        const gridLineY = new zrender.Line({
          shape: {
            x1: chartStartX,
            y1: gridY,
            x2: gridEndX + chartStartX,
            y2: gridY
          },
          style: {
            stroke: "lightgray"
          }
        });
        zr.add(gridLineY);
      }

      // Draw today line
      drawTodayLine(chartStartX, chartStartY, timeScaleHeight, barHeight, barMargin);

      // Draw milestones
      // MARK: 画里程碑线
      mileStones.forEach(function (item) {
        const milestone = new zrender.Rect({
          shape: {
            // x: chartStartX + milestone.start * unitWidth - 1 + halfUnitWidth,
            x: chartStartX + item.start * unitWidth - 1,
            y: chartStartY - timeScaleHeight,
            width: 2,
            height: tasks.length * (barHeight + barMargin) + timeScaleHeight
          },
          style: {
            fill: "rgba(255, 0, 0, 1)"
          },
          z: 1
        });
        const milestone_top = new zrender.Rect({
          shape: {
            x: chartStartX + item.start * unitWidth - 1,
            y: chartStartY - timeScaleHeight - milestoneTopHeight,
            width: 10,
            height: milestoneTopHeight
          },
          style: {
            fill: "rgba(255, 0, 0, 1)"
          },
          z: 1
        });
        const milestone_top_text = new zrender.Text({
          style: {
            x: chartStartX + item.start * unitWidth - 1 + 10,
            y: chartStartY - timeScaleHeight - milestoneTopHeight,
            text: item.name || '里程碑',
            fill: "white",
            lineHeight: milestoneTopHeight,
            fontSize: 12
          },
          z: 1
        });
        const milestone_top_text_rect = milestone_top_text.getBoundingRect()
        milestone_top.attr({
          shape: {
            width: milestone_top_text_rect.width + 10 * 2,
          }
        })
        zr.add(milestone);
        zr.add(milestone_top);
        zr.add(milestone_top_text);
      });

      let drawTaskBar = 0;
      // Draw tasks, resource assignments, and task bars
      // MARK: 画任务条
      tasks.forEach(function (task, index) {
        if (!task?.name) return
        // perf: 在视口外跳过
        if (index > Math.floor((canvasHeight - chartStartY) / (barHeight + barMargin))) return
        if (task.start > boundingRight || (task.start + task.duration) < boundingLeft) return
        drawTaskBar++;
        // Calculate position and dimensions
        const x = chartStartX + task.start * unitWidth;
        const y = chartStartY + (barHeight + barMargin) * index;
        const width = task.duration * unitWidth;
        const taskBarRect = {
          width,
          height: barHeight
        };
        // Create a group to hold task elements
        const group = new zrender.Group({
          position: [x, y],
          // draggable: true  // Enable draggable for the group
          draggable: "horizontal", // Enable draggable for the group
        });
        // Create a rectangle shape for each task
        const rect = new zrender.Rect({
          shape: {
            x: 0,
            y: 0,
            width: width,
            height: barHeight,
            r: 6
          },
          style: {
            // fill: task.fillColor || "blue"
            fill: task.fillColor
          },
          cursor: 'move'
        });
        group.add(rect);
        group.index = index;

        const w = 6;
        const box = rect.getBoundingRect();
        const leftBar = getLeftHandleBar(w, box, taskBarRect);
        leftBar.taskBar = rect;
        group.add(leftBar);

        const rightBar = getRightHandleBar(w, box, taskBarRect);
        rightBar.taskBar = rect;
        group.add(rightBar);

        group.on("mouseover", function () {
          if (this.dragging) return;

          rect.attr("style", { fill: zrender.color.lift(task.fillColor, 0.3) });
        });

        group.on("mouseout", function () {
          if (this.dragging || this.resizing) return;
          rect.attr("style", { fill: task.fillColor });
        });

        // zr.add(rect);

        // Create a text shape for task name
        const taskName = new zrender.Text({
          style: {
            text: task.name,
            x: taskNamePaddingLeft,
            y: barHeight / 2 - 12 / 2,
            textFill: "white",
            textAlign: "left",
            textVerticalAlign: "middle",
            fill: "white"
          },
          cursor: 'move'
        });
        
        // Create a text for duration
        const taskDurationText = new zrender.Text({
          style: {
            text: `${getRealDuration(task)}天`,
            x: width - taskNamePaddingLeft,
            y: barHeight / 2 - 12 / 2,
            textFill: "white",
            textAlign: "left",
            textVerticalAlign: "middle",
            fill: "white"
          },
          cursor: 'move'
        });
        const { width: taskDurationTextWidth } = taskDurationText.getBoundingRect()
        taskDurationText.attr({
          style: {
            x: width - taskDurationTextWidth - taskNamePaddingLeft
          }
        })
        // Create a text shape for resource assignment
        const resourceText = new zrender.Text({
          style: {
            text: "Assigned to: " + task.resource,
            x: 0 + width + 5,
            y: barHeight / 2 + 0 - 12 / 2,
            textFill: "black"
          },
          cursor: 'normal'
        });

        // 如果放不下，显示到resourceText上去，隐藏taskName
        if (taskName.getBoundingRect().width + taskDurationTextWidth + taskNamePaddingLeft * 2 > width) {
          resourceText.attr({
            style: {
              text: task.name
            }
          })
          taskName.hide();
        }
        group.add(taskName);
        group.add(taskDurationText);
        group.add(resourceText);

        // drag logic
        let dragStartX = 0;
        group.on("dragstart", function (e) {
          if (this.resizing) return;
          dragStartX = e.event.zrX;
          currentGroup = this
        });
        group.on("drag", function (e) {
          if (this.resizing) return;
        });
        group.on("dragend", function (e) {
          console.log('dragend')
          if (this.resizing) {
            this.resizing = false;
            return;
          }
          const deltaX = e.event.zrX - dragStartX;
          const dir = deltaX < 0 ? -1 : 1;
          const delta = Math.abs(deltaX);
          const mod = delta % unitWidth;
          const offsetX = dir * (Math.floor(delta / unitWidth) + Math.floor(mod / halfUnitWidth));
          if (!offsetX) return
          task.start += offsetX;
          syncLocal();
          currentGroup = null
          // Redraw the chart after dragging
          redrawChart(true);
        });
        group.eachChild(function (child) {
          child.attr({
            z: 10
          });
        });

        group.on("dblclick", function () {
          Popup.show()
          const $taskInput = document.querySelector('#current-task')

          $taskInput.value = JSON.stringify(tasks[this.index], null, 2);
          $taskInput.dataset.index = this.index
        });

        zr.add(group);
      });

      debug && console.log({
        drawTaskBar
      })
    }

    redrawChart();
  </script>
</body>

</html>