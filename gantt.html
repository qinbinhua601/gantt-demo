<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>gantt</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/zrender/5.4.4/zrender.min.js"></script>
  <style>
    #zrender-container,
    #off-screen {
      outline: 1px solid red;
      /* margin: 20px 0 0 150px; */
    }

    .popup-wrapper {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background-color: rgba(255, 0, 0, 0.3);
      /* display: flex; */
      align-items: center;
      justify-content: center;
      flex-direction: column;
      display: none;
    }

    .popup-wrapper .popup-wrapper__body .button-wrapper button,
    textarea {
      display: block;
    }

    .popup-wrapper .popup-wrapper__body .button-wrapper {
      display: flex;
    }

    .popup-wrapper .popup-wrapper__body .button-wrapper button {
      margin-right: 10px;
    }
  </style>
</head>

<body>
  <div class="control-item">
    <!-- Reset the scroll button -->
    <button id="back-to-origin-button">重置滚动</button>
    <span id="last-scroll-x">0</span>
  </div>
  <div class="control-item" style="display: none;">
    <!-- clear all tasks -->
    <button id="clear-button">清空任务</button>
    <button id="clear-milestone-button">清空里程</button>
  </div>
  <!-- Create a container for the ZRender instance -->
  <div id="zrender-container" style="height: 800px;"></div>
  <!-- popup 提示框 -->
  <div class="popup-wrapper">
    <div class="popup-wrapper__body">
      <form>
        <textarea name="taskvalue" cols="30" rows="10" id="current-task" data-index="0"></textarea>
        <div class="button-wrapper">
          <button class="modify">修改</button>
          <button class="delete">删除</button>
        </div>
      </form>
    </div>
  </div>
  <script src="./hachure.js"></script>
  <script src="./holidays.js"></script>
  <script src="./controls.js"></script>
  <script src="./utils.js"></script>
  <script>
    // console.log(hachureLines)
    let currentGroup = null;
    let lastHandleMove = null;
    const debug = false;

    const defaultTaskOwner = 'alexq';
    // Initialize ZRender
    const zr = zrender.init(document.getElementById("zrender-container"), {
      renderer: 'canvas'
    });
    // unit width of the column
    let unitWidth = getParamsFromSearch() ?? 160;
    // half unit width
    let halfUnitWidth = unitWidth / 2;
    // taskName paddingLeft
    let taskNamePaddingLeft = getParamsFromSearch('taskNamePaddingLeft') ?? 30;
    const useLocal = getParamsFromSearch('useLocal');
    // Define tasks for the Gantt chart`
    const tasks = useLocal ? getLocal() : [
      { name: "Task 1", start: 0, duration: 3, resource: "John", fillColor: getRandomColor() },
      { name: "Task 2", start: 2, duration: 4, resource: "Jane", fillColor: getRandomColor() },
      { name: "Task 3", start: 6, duration: 2, resource: "Bob", fillColor: getRandomColor() },
      { name: "Task 4", start: 8, duration: 2, resource: "Bob", fillColor: getRandomColor() },
      { name: "Task 5", start: 10, duration: 8, resource: "Uni", fillColor: getRandomColor() },
      {}
      // Add more tasks as needed
    ];
    window.tasks = tasks;

    // Define the milestones
    const mileStones = useLocal ? getLocal('mileStones') : [
      { start: 10, name: '提测' }
    ];
    window.mileStones = mileStones;
    function createFlag() {
      const flag = zrender.path.createFromString('M3.333,10v 5 c0,0.184 -0.149, 0.333 -0.333, 0.333 h-0.667A0.333, 0.333 0 0 1 2, 15 V 1.333 c0, -0.368 0.298, -0.666 0.667, -0.666 h 11.525 a 0.667, 0.667 0 0 1 0.581, 0.994 L 12.76, 5.233 a 0.333, 0.333 0 0 0 0.002, 0.33 L 14.753, 9 A 0.667, 0.667 0 0 1 14.176, 10 H 3.333z', {
        style: {
          fill: '#F54A45'
        }
      })
      return flag;
    }
    function createFlagGroup(gridX, halfUnitWidth, chartStartY, timeScaleHeight) {
      const flagGroup = new zrender.Group()
      const flag = createFlag()
      const { width: fWidth, height: fHeight } = flag.getBoundingRect()
      flag.attr('position', [gridX + halfUnitWidth - fWidth / 2, (chartStartY - timeScaleHeight) + timeScaleHeight / 2 - fHeight / 2])
      const flagHoveredCircle = new zrender.Circle({
        shape: {
          cx: gridX + halfUnitWidth + 1,
          cy: (chartStartY - timeScaleHeight) + timeScaleHeight / 2,
          r: 12
        },
        style: {
          fill: 'rgba(211, 211, 211, 0.5)'
        }
      })
      flagGroup.add(flagHoveredCircle)
      flagGroup.add(flag)
      flagGroup.hide()
      zr.add(flagGroup)
      return [flagGroup, {
        flag,
        flagHoveredCircle
      }]
    }
    function getRandomColor() {
      // Generate random values for red, green, and blue components
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);

      // Convert values to hexadecimal and format the color
      const hexColor = '#' + r.toString(16).padStart(2, '0') +
        g.toString(16).padStart(2, '0') +
        b.toString(16).padStart(2, '0');

      return hexColor;
    }

    function getTimeScaleWidthByTasks(tasks) {
      let min = 1000000000,
        max = -1;
      tasks.forEach((task) => {
        const { start = 0, duration = 0 } = task;
        min = Math.min(start, min);
        max = Math.max(max, start + duration);
      });
      return max - min;
    }

    function getLeftHandleBar(w, box, taskBarRect) {
      const { height: barHeight, width } = taskBarRect;
      const leftBar = new zrender.Rect({
        name: "leftBar",
        style: {
          fill: `rgba(0, 255, 0, ${debug ? 1 : 0})`,
          lineWidth: 1
        },
        shape: {
          width: w,
          height: barHeight
        },
        draggable: "horizontal",
        cursor: "ew-resize",
        z: 1
      });
      leftBar.attr({
        position: [box.x, box.y],
        shape: {
          x: -w / 2,
          y: 0
        }
      });
      let dragStartX = 0;
      let oldX = 0;
      let oldWidth = 0;
      leftBar.on("dragstart", function (e) {
        this.parent.resizing = true;
        dragStartX = e.event.zrX;
        const taskBar = this.taskBar;
        oldWidth = taskBar.shape.width;
        oldX = taskBar.shape.x;
        currentGroup = this.parent;
      });
      leftBar.on("drag", function (e) {
        const deltaX = e.event.zrX - dragStartX;
        const taskBar = this.taskBar;
        taskBar.attr({
          shape: {
            x: oldX + deltaX,
            width: oldWidth - deltaX
          }
        });
      });
      leftBar.on("dragend", function (e) {
        const deltaX = e.event.zrX - dragStartX;
        const dir = deltaX < 0 ? -1 : 1;
        const delta = Math.abs(deltaX);
        const mod = delta % unitWidth;
        const offsetX = dir * (Math.floor(delta / unitWidth) + Math.floor(mod / halfUnitWidth));
        console.log(offsetX)
        const task = tasks[this.parent.index];
        task.start += offsetX;
        task.duration -= offsetX;
        syncLocal();
        currentGroup = null;
        // Redraw the chart after dragging
        redrawChart(true);
      });
      return leftBar;
    }

    function getRightHandleBar(w, box, taskBarRect) {
      const { height: barHeight, width } = taskBarRect;
      const rightBar = new zrender.Rect({
        style: {
          fill: `rgba(255, 192, 203, ${debug ? 1 : 0})`,
          lineWidth: 1
        },
        shape: {
          width: w,
          height: barHeight
        },
        draggable: "horizontal",
        cursor: "ew-resize",
        z: 1
      });
      rightBar.attr({
        position: [box.x + width, box.y],
        shape: {
          x: -w / 2,
          y: 0
        }
      });
      let dragStartX = 0;
      let oldX = 0;
      let oldWidth = 0;
      rightBar.on("dragstart", function (e) {
        this.parent.resizing = true;
        dragStartX = e.event.zrX;
        const taskBar = this.taskBar;
        oldWidth = taskBar.shape.width;
        oldX = taskBar.shape.x;
        console.log(currentGroup)
        currentGroup = this.parent
      });
      rightBar.on("drag", function (e) {
        const deltaX = e.event.zrX - dragStartX;
        const taskBar = this.taskBar;
        taskBar.attr({
          shape: {
            width: oldWidth + deltaX
          }
        });
      });
      rightBar.on("dragend", function (e) {
        const deltaX = e.event.zrX - dragStartX;
        const dir = deltaX < 0 ? -1 : 1;
        const delta = Math.abs(deltaX);
        const mod = delta % unitWidth;
        const offsetX = dir * (Math.floor(delta / unitWidth) + Math.floor(mod / halfUnitWidth));
        const task = tasks[this.parent.index];
        task.duration += offsetX;
        syncLocal();
        currentGroup = null
        // Redraw the chart after dragging
        redrawChart(true);
      });
      return rightBar;
    }

    function drawTodayLine(chartStartX, chartStartY, timeScaleHeight, barHeight, barMargin) {
      const todayLine = new zrender.Rect({
        shape: {
          x: chartStartX + todayOffset * unitWidth - 1 + halfUnitWidth,
          y: chartStartY,
          width: 2,
          height: tasks.length * (barHeight + barMargin)
        },
        style: {
          fill: "#2955c9"
        },
        z: 1
      });
      const circle = new zrender.Circle({
        shape: {
          cx: chartStartX + todayOffset * unitWidth + halfUnitWidth,
          cy: chartStartY - timeScaleHeight + timeScaleHeight + 2,
          r: 3
        },
        style: {
          fill: "#2955c9"
        }
      })
      zr.add(todayLine);
      zr.add(circle);
    }

    const todayOffset = Math.floor((+new Date() - +new Date('2024-01-01')) / (60 * 60 * 24 * 1000))
    // scroll horizontally
    let lastScrollX = 0 + (todayOffset - 1) * unitWidth, lastScrollY = 0;
    const $lastScrollXSpan = document.querySelector('#last-scroll-x');
    zr.on('mousewheel', function (e) {
      e.event.preventDefault();
      // console.log(e.event, e.event.wheelDeltaX);
      lastScrollX -= e.event.wheelDeltaX;
      redrawChart(true, lastScrollX, 0);
      $lastScrollXSpan.innerText = lastScrollX;
    })
    // redraw when browser window size change
    window.addEventListener('resize', function() {
      zr.resize();
      redrawChart(true);
    });
    const initChartStartX = 1, initChartStartY = 50;
    function redrawChart(clear, scrollX = lastScrollX, scrollY = 0) {
      // time scale height
      const timeScaleHeight = getParamsFromSearch('timeScaleHeight') ?? 20;
      // milestone top height
      const milestone_top_height = getParamsFromSearch('milestone_top_height') ?? 20;
      // margin left to the container
      const chartStartX = initChartStartX - scrollX;
      // margin top to the container
      const chartStartY = Math.max(initChartStartY, timeScaleHeight + milestone_top_height) - scrollY;
      // taskBar height
      const barHeight = getParamsFromSearch('barHeight') ?? 30;

      // taskBar margin bottom
      const barMargin = debug ? 10 : 1;

      clear && zr.clear();

      // const timeScaleWidth = getTimeScaleWidthByTasks(tasks);

      // hover day grid to add task
      let lastPos
      let lastDayRect
      function handleMove(e) {
        if (currentGroup?.resizing || currentGroup?.dragging) {
          return
        }
        const x = e.event.zrX - chartStartX
        const y = e.event.zrY - chartStartY
        const posX = Math.floor(x / unitWidth)
        const posY = Math.floor(y / (barHeight + barMargin))
        if (lastPos !== [posX, posY].join()) {
          lastPos = [posX, posY].join()
          // if (true || (posX >= 0 && posX < timeScaleWidth && posY >= 0 && posY < tasks.length)) {
          if (posY >= 0 && posY < tasks.length) {
            // console.log('zr', 'clicked', posX, posY)
            const hasTask = posX >= tasks[posY].start && posX < tasks[posY].start + tasks[posY].duration
            if (hasTask) {
              lastDayRect && zr.remove(lastDayRect)
              return
            }
            const dayHoverGroup = new zrender.Group()
            dayHoverGroup.on('click', function () {
              console.log('dayHoverGroup clicked pos: ', [posX, posY])
              // alert([posX, posY])
              const taskName = prompt('task name?');
              if (!taskName) return
              const resourceName = prompt('assign to who?') || defaultTaskOwner;
              tasks.splice(posY, 0, { name: taskName, start: posX, duration: 1, resource: resourceName, fillColor: getRandomColor() });
              syncLocal();
              redrawChart(true)
            })
            // draw the hover rect on the day grid
            const dayRect = new zrender.Rect({
              shape: {
                x: chartStartX + unitWidth * posX + 5,
                y: chartStartY + (barHeight + barMargin) * posY,
                width: unitWidth - 10,
                height: barHeight + barMargin,
              },
              style: {
                fill: 'transparent',
                stroke: 'gray',
                lineDash: [5, 7]
              },
              z: 100
            })
            const rowHoverRect = new zrender.Rect({
              shape: {
                x: chartStartX + lastScrollX,
                y: chartStartY + (barHeight + barMargin) * posY,
                width: unitWidth * timeScaleWidth,
                height: barHeight + barMargin,
              },
              style: {
                fill: 'rgba(221, 221, 221, 0.3)',
              },
              z: 1
            })
            const lineH = new zrender.Line({
              shape: {
                x1: chartStartX + unitWidth * posX + unitWidth / 2 - 5,
                y1: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2,
                x2: chartStartX + unitWidth * posX + unitWidth / 2 + 5,
                y2: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2
              },
              style: {
                stroke: 'gray'
              },
              z: 100
            })
            const lineV = new zrender.Line({
              shape: {
                x1: chartStartX + unitWidth * posX + unitWidth / 2,
                y1: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2 - 5,
                x2: chartStartX + unitWidth * posX + unitWidth / 2,
                y2: chartStartY + (barHeight + barMargin) * posY + (barHeight + barMargin) / 2 + 5
              },
              style: {
                stroke: 'gray'
              },
              z: 100
            })
            dayHoverGroup.add(dayRect)
            dayHoverGroup.add(lineH)
            dayHoverGroup.add(lineV)
            dayHoverGroup.add(rowHoverRect)
            lastDayRect && zr.remove(lastDayRect)
            lastDayRect = dayHoverGroup
            zr.add(dayHoverGroup)
          } else {
            lastDayRect && zr.remove(lastDayRect)
            // console.log('invalid pos')
          }
        } else {
          // lastDayRect && zr.remove(lastDayRect)
          // console.log('same as the last pos')
        }
      }
      lastHandleMove && zr.off('mousemove', lastHandleMove)
      lastHandleMove = handleMove
      zr.on('mousemove', handleMove);

      const canvasWidth = zr.getWidth();
      const canvasHeight = zr.getHeight();
      const timeScaleWidth = Math.ceil((canvasWidth) / unitWidth);
      // Draw time scale
      // MARK: 日期时间轴
      const timeScale = new zrender.Rect({
        shape: {
          x: chartStartX + lastScrollX,
          y: chartStartY - timeScaleHeight,
          width: timeScaleWidth * unitWidth,
          height: timeScaleHeight
        },
        style: {
          // fill: "lightgray"
          fill: "rgba(255, 0,0, .2)"
        }
      });
      zr.add(timeScale);

      // Draw vertical grid lines
      // MARK: grid 竖线
      const gridStartX = chartStartX;
      const gridEndX = timeScaleWidth * unitWidth;
      const gridLineCount = timeScaleWidth + 1;
      const deltaScrollX = Math.floor(lastScrollX / unitWidth);
      for (let i = 0 + deltaScrollX, count = 0; count < gridLineCount; i++,count++) {
        const gridX = gridStartX + i * unitWidth;
        const gridLine = new zrender.Line({
          shape: {
            x1: gridX,
            y1: chartStartY - timeScaleHeight,
            x2: gridX,
            y2: chartStartY + (barHeight + barMargin) * tasks.length
          },
          style: {
            stroke: "lightgray"
          }
        });

        // draw the date
        if (count < gridLineCount - 1) {
          // MARK: 同一个遍历画「休息日斜线」
          const now = +new Date('2024-01-01');
          const currentDate = now + i * 60 * 1000 * 60 * 24
          const dateInfo = isHoliday(currentDate)
          // draw the hachure fill
          if (dateInfo.isHoliday) {
            // if (i % 7 == 0 || i % 7 === 1) {
            try {
              const lines = hachureLines([
                [chartStartX + i * unitWidth, chartStartY],
                [chartStartX + i * unitWidth + unitWidth, chartStartY],
                [chartStartX + i * unitWidth + unitWidth, chartStartY + (barHeight + barMargin) * tasks.length],
                [chartStartX + i * unitWidth, chartStartY + (barHeight + barMargin) * tasks.length]
              ], 10, 45);
              // console.log(lines)
              lines.forEach(line => {
                const [x1, y1] = line[0]
                const [x2, y2] = line[1]
                const l = new zrender.Line({
                  shape: {
                    x1, y1, x2, y2
                  },
                  style: {
                    stroke: 'rgba(221, 221, 221, 0.7)'
                  }
                })
                zr.add(l)
              })
            } catch (error) {
              console.log(error)
            }
          }
          // MARK: 画日期文字
          const dateText = new zrender.Text({
            style: {
              // text: i,
              text: dateInfo.dateString,
              x: gridX,
              y: chartStartY - timeScaleHeight,
            },
            z: 1
          });
          const [flagGroup, {
            flag
          }] = createFlagGroup(gridX, halfUnitWidth, chartStartY, timeScaleHeight)
          dateText.on('click', function () {
            console.log('date text click', i);
            const index = mileStones.findIndex(item => item.start === i)
            if (index === -1) {
              if (confirm('Do you want to CREATE a milestone here?')) {
                const mileStoneName = prompt('mileStone name?');
                mileStones.push({
                  start: i,
                  name: mileStoneName
                });
                syncLocal();
              }
            } else {
              if (confirm('Do you want to DELETE the milestone here?')) {
                mileStones.splice(index, 1)
                syncLocal();
              }
            }
            redrawChart(true)
          })
          dateText.on('mouseover', function (e) {
            this.attr({
              style: {
                opacity: 0
              }
            });
            flagGroup.show()
          })
          dateText.on('mouseout', function (e) {
            this.attr({
              style: {
                opacity: 1
              }
            });
            flagGroup.hide()
          })

          const { width, height } = dateText.getBoundingRect()
          dateText.attr({
            style: {
              x: gridX - width / 2 + halfUnitWidth,
              y: chartStartY - timeScaleHeight - height / 2 + timeScaleHeight / 2,
            }
          })
          zr.add(dateText);
        }
        zr.add(gridLine);
      }

      // Draw horizontally grid lines
      // MARK: 画grid横线
      const gridLineCountY = tasks.length + 1;

      // for (let j = 0; j < gridLineCountY; j++) {
      for (let j = 0; j < 1; j++) {
        const gridY = chartStartY + j * (barHeight + barMargin);
        const gridLineY = new zrender.Line({
          shape: {
            x1: chartStartX,
            y1: gridY,
            x2: gridEndX + chartStartX,
            y2: gridY
          },
          style: {
            stroke: "lightgray"
          }
        });
        zr.add(gridLineY);
      }

      // draw today line
      drawTodayLine(chartStartX, chartStartY, timeScaleHeight, barHeight, barMargin);

      // Draw milestones
      // MARK: 画里程碑线
      mileStones.forEach(function (item) {
        const milestone = new zrender.Rect({
          shape: {
            // x: chartStartX + milestone.start * unitWidth - 1 + halfUnitWidth,
            x: chartStartX + item.start * unitWidth - 1,
            y: chartStartY - timeScaleHeight,
            width: 2,
            height: tasks.length * (barHeight + barMargin) + timeScaleHeight
          },
          style: {
            fill: "rgba(255, 0, 0, 1)"
          },
          z: 1
        });
        const milestone_top = new zrender.Rect({
          shape: {
            x: chartStartX + item.start * unitWidth - 1,
            y: chartStartY - timeScaleHeight - milestone_top_height,
            width: 10,
            height: milestone_top_height
          },
          style: {
            fill: "rgba(255, 0, 0, 1)"
          },
          z: 1
        });
        const milestone_top_text = new zrender.Text({
          style: {
            x: chartStartX + item.start * unitWidth - 1 + 10,
            y: chartStartY - timeScaleHeight - milestone_top_height,
            text: item.name || '里程碑',
            fill: "white",
            lineHeight: milestone_top_height,
            fontSize: 12
          },
          z: 1
        });
        const milestone_top_text_rect = milestone_top_text.getBoundingRect()
        milestone_top.attr({
          shape: {
            width: milestone_top_text_rect.width + 10 * 2,
          }
        })
        zr.add(milestone);
        zr.add(milestone_top);
        zr.add(milestone_top_text);
      });

      // Draw tasks, resource assignments, and task bars
      // MARK: 画任务条
      tasks.filter(item => item?.name).forEach(function (task, index) {
        // Calculate position and dimensions
        const x = chartStartX + task.start * unitWidth;
        const y = chartStartY + (barHeight + barMargin) * index;
        const width = task.duration * unitWidth;
        const taskBarRect = {
          width,
          height: barHeight
        };
        // Create a group to hold task elements
        const group = new zrender.Group({
          position: [x, y],
          // draggable: true  // Enable draggable for the group
          draggable: "horizontal", // Enable draggable for the group
        });
        // Create a rectangle shape for each task
        const rect = new zrender.Rect({
          shape: {
            x: 0,
            y: 0,
            width: width,
            height: barHeight,
            r: 6
          },
          style: {
            // fill: task.fillColor || "blue"
            fill: task.fillColor
          },
          cursor: 'move'
        });
        group.add(rect);
        group.index = index;

        const w = 6;
        const box = rect.getBoundingRect();
        const leftBar = getLeftHandleBar(w, box, taskBarRect);
        leftBar.taskBar = rect;
        group.add(leftBar);

        const rightBar = getRightHandleBar(w, box, taskBarRect);
        rightBar.taskBar = rect;
        group.add(rightBar);

        group.on("mouseover", function () {
          if (this.dragging) return;

          rect.attr("style", { fill: zrender.color.lift(task.fillColor, 0.3) });
        });

        group.on("mouseout", function () {
          if (this.dragging || this.resizing) return;
          rect.attr("style", { fill: task.fillColor });
        });

        // zr.add(rect);

        // Create a text shape for task name
        const taskName = new zrender.Text({
          style: {
            text: task.name,
            x: 0 + taskNamePaddingLeft,
            y: 0 + barHeight / 2 - 12 / 2,
            textFill: "white",
            textAlign: "left",
            textVerticalAlign: "middle",
            fill: "white"
          },
          cursor: 'move'
        });
        group.add(taskName);

        // Create a text shape for resource assignment
        const resourceText = new zrender.Text({
          style: {
            text: "Assigned to: " + task.resource,
            x: 0 + width + 5,
            y: barHeight / 2 + 0 - 12 / 2,
            textFill: "black"
          },
          cursor: 'normal'
        });
        group.add(resourceText);

        // drag logic
        let dragStartX = 0;
        group.on("dragstart", function (e) {
          if (this.resizing) return;
          dragStartX = e.event.zrX;
          currentGroup = this
        });
        group.on("drag", function (e) {
          if (this.resizing) return;
        });
        group.on("dragend", function (e) {
          if (this.resizing) {
            this.resizing = false;
            return;
          }
          const deltaX = e.event.zrX - dragStartX;
          const dir = deltaX < 0 ? -1 : 1;
          const delta = Math.abs(deltaX);
          const mod = delta % unitWidth;
          const offsetX = dir * (Math.floor(delta / unitWidth) + Math.floor(mod / halfUnitWidth));
          task.start += offsetX;
          syncLocal();
          currentGroup = null
          // Redraw the chart after dragging
          redrawChart(true);
        });
        group.eachChild(function (child) {
          child.attr({
            z: 10
          });
        });

        group.on("dblclick", function () {
          Popup.show()
          const $taskInput = document.querySelector('#current-task')

          $taskInput.value = JSON.stringify(tasks[this.index], null, 2);
          $taskInput.dataset.index = this.index
        });

        zr.add(group);

        // Update the Y position for the next task
        // chartStartY += barHeight + barMargin;
      });
    }

    redrawChart();

    // popup modal
    let Popup = {};

    Popup.show = function () {
      if (!Popup.el) {
        const $popup = document.querySelector('.popup-wrapper')
        const $popupBody = document.querySelector('.popup-wrapper__body');
        const $button = $popup.querySelector('button.modify');
        const $deleteButton = $popup.querySelector('button.delete');

        $popup.addEventListener('click', function () {
          Popup.hide();
        });

        $button.onclick = function (e) {
          e.preventDefault();
          const value = this.parentElement.previousElementSibling.value;
          const index = this.parentElement.previousElementSibling.dataset.index;
          tasks.splice(index, 1, JSON.parse(value));
          syncLocal();
          Popup.hide();
          redrawChart(true);
        }

        $deleteButton.onclick = function (e) {
          e.preventDefault();
          const index = this.parentElement.previousElementSibling.dataset.index;
          if (confirm('Are you sure to DELETE the task?')) {
            tasks.splice(index, 1)
            syncLocal();
          }
          Popup.hide();
          redrawChart(true);
        }

        $popupBody.onclick = function (e) { e.stopPropagation(); }

        Popup.el = $popup;
      }

      Popup.el.style.display = 'flex';
    }
    Popup.hide = function () {
      Popup.el.style.display = 'none';
    }
  </script>
</body>

</html>